
{
  "rules": {
    "users": {
      "$uid": {
        ".read": "auth != null", // Allow authenticated users to read any profile (e.g. for contacts)
        ".write": "auth != null && auth.uid === $uid", // Only owner can write to their profile
        "email": { ".validate": "newData.isString() && newData.val().length > 0" },
        "name": { ".validate": "newData.isString() && newData.val().length > 0" },
        "avatarUrl": { ".validate": "newData.isString()" },
        "lastLogin": { ".validate": "newData.isString()" }, // ISO Date string
        "createdAt": { ".validate": "newData.isString()" }, // ISO Date string
        "$other": { ".validate": false }
      },
      ".indexOn": ["email"] // For querying users by email
    },
    "user_contacts": {
      "$currentUserId": {
        ".read": "auth != null && auth.uid === $currentUserId",
        ".write": "auth != null && auth.uid === $currentUserId",
        "$contactUserId": {
          "id": { ".validate": "newData.isString() && newData.val() === $contactUserId" },
          "name": { ".validate": "newData.isString() && newData.val().length > 0" },
          "avatarUrl": { ".validate": "newData.isString()" },
          "addedAt": { ".validate": "newData.isString()" }, // ISO Date string
          "$other": { ".validate": false }
        },
        ".indexOn": ["name"] // For sorting/searching contacts by name
      }
    },
    "personas": {
      "$userId": {
        ".read": "auth != null && auth.uid === $userId",
        ".write": "auth != null && auth.uid === $userId",
        "$personaId": {
          "id": { ".validate": "newData.isString() && newData.val() === $personaId" },
          "name": { ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length <= 50" },
          "personaDescription": { ".validate": "newData.isString()" },
          "createdAt": { ".validate": "newData.isString()" },
          "avatarUrl": { ".validate": "newData.isString()" },
          "category": { ".validate": "newData.isString() && newData.val().length <= 50" },
          "originType": { ".validate": "newData.val() === 'user-created' || newData.val() === 'chat-derived'" },
          // Fields for 'user-created'
          "chatHistory": { ".validate": "newData.isString()" },
          "mbti": { ".validate": "newData.isString()" },
          "age": { ".validate": "newData.isNumber() && newData.val() >= 1 && newData.val() <= 120" },
          "gender": { ".validate": "newData.isString()" },
          // personalityInsights can be complex, allow object
          "personalityInsights": { ".validate": "newData.isObject() || newData.isString()" }, // Allow old string or new object
          // Fields for 'chat-derived'
          "derivedFromChatId": { ".validate": "newData.isString()" },
          "derivedRepresentingUserId": { ".validate": "newData.isString()" },
          "sourceChatMessagesCount": { ".validate": "newData.isNumber()" },
          // Allow only defined fields, ensure types. Add other optional fields here with .validate if needed
          "$other": { ".validate": false }
        },
        ".indexOn": ["createdAt", "category", "derivedFromChatId"] // For sorting, grouping and chat-derived lookup
      }
    },
    "ai_chat_messages": {
      "$userId": {
        "$personaId": {
          ".read": "auth != null && auth.uid === $userId",
          ".write": "auth != null && auth.uid === $userId", // User can write messages for their own personas
          "$messageId": {
            ".validate": "newData.hasChildren(['sender', 'text', 'timestamp']) && (newData.child('sender').val() === 'user' || newData.child('sender').val() === 'ai') && newData.child('text').isString() && newData.child('text').val().length > 0 && (newData.child('timestamp').val() === serverTimestamp || newData.child('timestamp').isNumber() || newData.child('timestamp').isString()) && (!newData.hasChild('context') || newData.child('context').isString())",
            "sender": { ".validate": "newData.val() === 'user' || newData.val() === 'ai'" },
            "text": { ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 10000" },
            "timestamp": { ".validate": "newData.val() === serverTimestamp || newData.isNumber() || newData.isString()" },
            "context": { ".validate": "newData.isString()" },
            "$other": { ".validate": false }
          },
          ".indexOn": "timestamp"
        }
      }
    },
    "user_chat_messages": {
      "$chatId": { // $chatId is "uid1_uid2" sorted
        ".read": "auth != null && ($chatId.split('_')[0] === auth.uid || $chatId.split('_')[1] === auth.uid)",
        // Only participants of the chat can write to it. Clearing chat (removing node) is covered here.
        ".write": "auth != null && ($chatId.split('_')[0] === auth.uid || $chatId.split('_')[1] === auth.uid)",
        "$messageId": {
          // When a new message is created, its senderUserId must be the authenticated user.
          ".validate": "newData.hasChildren(['senderUserId', 'text', 'timestamp']) && newData.child('senderUserId').isString() && newData.child('senderUserId').val() === auth.uid && newData.child('text').isString() && newData.child('text').val().length > 0 && newData.child('text').val().length < 10000 && (newData.child('timestamp').val() === serverTimestamp || newData.child('timestamp').isNumber() || newData.child('timestamp').isString())",
          "senderUserId": { ".validate": "newData.isString() && newData.val() === auth.uid" },
          "text": { ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length < 10000" },
          "timestamp": { ".validate": "newData.val() === serverTimestamp || newData.isNumber() || newData.isString()" },
          "$other": { ".validate": false }
        },
        ".indexOn": "timestamp"
      }
    }
  }
}
